[{invert}]
= Versions

== Pourquoi faire des versions ?

* Un changement visible d'un logiciel peut n√©cessiter une adaptation de ses utilisateurs
* Un humain √ßa s'adapte, mais un logiciel il faut l'adapter!
* Cela permet de contr√¥ler le probl√®me de la compatibilit√© entre deux logiciels.

== Une petite histoire

Le logiciel que vous d√©veloppez utilise des donn√©es d'une API d'un site de vente.

[source,json]
--
// Corps de la r√©ponse d'une requ√™te GET https://supersite.com/api/item
[
  {
    "identifier": 1343,
    // ...
  }
]
--

Voici comment est repr√©sent√© un item vendu dans votre code.

[source,java]
--
public class Item {
  // Identifiant de l'item repr√©sent√© sous forme d'entier.
  private int identifier;
  // ...
}
--

[%notitle]
== Une petite histoire

Le site d√©cide tout d'un coup de changer le format de l'identifiant de son objet en cha√Æne de caract√®res.

[source,json]
--
// Corps de la r√©ponse d'une requ√™te GET https://supersite.com/api/item
[
  {
    "identifier": "lolilol3843",
    // ...
  }
]
--

Que se passe t'il du c√¥t√© de votre application ?

[%notitle]
== !

`com.fasterxml.jackson.databind.JsonMappingException`


image::explosion.gif[width="800"]

== Qu'est s'est il pass√© ?

* Votre application ne s'attendait pas √† un identifiant sous forme de cha√Æne de caract√®res !
* Le fournisseur de l'API √† "chang√© le contrat" de son API d'une fa√ßon non r√©trocompatible avec votre l'existant.
** Cela s'appelle un üá¨üáß *Breaking Change*

== Comment √©viter cela ?

* Laisser aux utilisateurs une marge de man≈ìuvre pour "accepter" votre changement.
** Donner une garantie de maintien des contrats existants.
** Informer vos utilisateurs d'un changement non r√©trocompatible.
** Anticiper les changements non r√©trocompatibles √† l'aide de strat√©gies (d√©pr√©ciation).

== Bonjour versions !

* Une version cristallise un contrat respect√© par votre application.
* C'est un jalon dans l'histoire de votre logiciel

[.notes]
--
Valide d'un point de vue fonctionnel et aussi technique
--

== Quoi versionner ?

Le probl√®me de la compatibilit√© existe d√®s qu'une d√©pendance entre deux bouts de code existe.

* Une API
* Une librairie
* Un langage de programmation
* Le noyau linux

== Version s√©mantique

La norme est l'utilisation du format vX.Y.Z (Majeur.Mineur.Patch)

image:semver.png[width="600"]

(source link:https://medium.com/better-programming/why-versioning-is-important-and-how-to-do-it-686ce13b854f[betterprograming])

[%notitle]
== !

Un changement **ne changeant pas le p√©rim√®tre fonctionnel** incr√©mente le num√©ro de version **patch**.

[.notes]
--
Example:

Un bugfix
--

[%notitle]
== !

Un changement changeant le p√©rim√®tre fonctionnel de fa√ßon **r√©trocompatible** incr√©mente le num√©ro de version **mineure**.

[.notes]
--

Example:

Ajout d'une fonctionnalit√© suppl√©mentaire (nouvelle route dans une API).
--

[%notitle]
== !


Un changement changeant le p√©rim√®tre fonctionnel de fa√ßon **non r√©trocompatible** incr√©mente le num√©ro de version **majeure**.

[.notes]
--

Example:

Retrait d'une fonctionnalit√© (retrait d'une route dans une API).
--

== En r√©sum√©

* Changer de version mineure ne devrait avoir aucun d'impact sur votre code.
* Changer de version majeure peut n√©cessiter des adaptations.

==  Concr√®tement avec une API

* Offrir a l'utilisateur un moyen d'indiquer la version de l'API a laquelle il souhaite parler
** Via un pr√©fixe dans le chemin de la requ√™te:
*** `https://monsupersite.com/api/v2.3/item`

** Via un en-t√™te HTTP:
*** `Accept-version: v2.3`

== Version VS Git

* Un identifiant de commit est de granularit√© trop faible pour un l'utilisateur externe.
* Utilisation de *tags* git pour d√©finir des versions.
* Un *tag* git est une r√©f√©rence sur un commit.

== üéì "taguez" et d√©ployez la version 1.0.0 de `cowsay`

* Si vous n'avez pas d√©j√† un compte sur le DockerHub, cr√©ez-en un maintenant (n√©cessite une validation)

* Depuis GitPod, cr√©ez un tag git local `1.0.0`
** üí° `git tag 1.0.0 -a -m "Premi√®re release 1.0.0, mode manuel"`

* Fabriquez l'image Docker de `cowsay` avec le tag (Docker) 1.0.0
** üí° `docker image build --tag=XXXX/cowsay:1.0.0 #...` avec `XXXX` √©tant votre username DockerHub

* D√©ployez l'image sur le DockerHub
** üí° `docker login`
** üí° `docker image push`

* D√©ployez le tag sur GitHub
** üí° `git push origin <tagname>`

== ‚úÖ "taguez" et d√©ployez la version 1.0.0 de `cowsay`

[source,bash]
----
DOCKER_USERNAME=dduportal
TAG=1.0.0

git tag "${TAG}" -a -m "Premi√®re release ${TAG}, mode manuel"

docker image build --tag="${DOCKER_USERNAME}"/cowsay:"${TAG}" ./
docker login --username="${DOCKER_USERNAME}"
# ...

docker image push "${DOCKER_USERNAME}"/cowsay:"${TAG}"

git push origin "${TAG}"

# Check DockerHub et GitHub apr√®s √ßa
----

== Checkpoint üéØ

* La notion de "version" est un outil de communication aux consommateurs de nos produits logiciels

* Le "semantic versioning" est une des fa√ßon les plus usit√©es pour g√©rer les politiques de version

* Nous avons d√©ploy√© manuellement notre premi√®re image Docker, avec synchronisation code source <-> image Docker

=> ü§î C'√©tait fort manuel. Et si on regardait √† automatiser tout √ßa ?
