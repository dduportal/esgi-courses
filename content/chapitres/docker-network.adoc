[{invert}]
= Docker : RÃ©seau

== ğŸ¤” Quel est le problÃ¨me ?

* Comment accÃ©der aux serveurs webs dans des conteneurs ?

== RÃ©seau dans Docker

* Docker utilise des rÃ©seaux virtuels privÃ©s
** Un peu comme votre box internet

* Votre point d'entrÃ©e : la commande https://docs.docker.com/engine/reference/commandline/network/[`docker network`]
** ğŸ“ Affichons la liste des rÃ©seaux par dÃ©faut :
+
[source,bash]
----
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
9affa4f4faa9   bridge    bridge    local
d454eb8cca5a   host      host      local
80a73237a778   none      null      local
----

== RÃ©seau Bridge `default`

image::docker-bridge-1.png[]

== ğŸ¤” Comment accÃ©der au serveur web en tÃ¢che de fond ?

* Assurez-vous que le conteneur `webserver-1` est toujours en fonctionnement
** Sinon: link:/#/exercice_conteneur_en_tÃ¢che_de_fond[ğŸ“ Exercice : conteneur en tÃ¢che de fond]

[source,bash]
----
$ docker container ls
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
ee5b70fa72c3   nginx     "/docker-entrypoint.â€¦"   3 seconds ago   Up 2 seconds   80/tcp    webserver-1
----

=> Super, le port 80 (TCP) est annoncÃ© (on parle d'"exposÃ©"). Mais oÃ¹ ?

== ğŸ“ Un client HTTP en ligne de commande

En utilisant la ligne de commande `curl`, affichez en ligne de commande :

* Le contenu (HTML) de la page http://google.com
* Les en-tÃªte HTTP (requÃªte et rÃ©ponse) associÃ©s Ã  la page http://google.com
* Le contenu de la page vers laquelle http://google.com redirige

[small]
ğŸ’¡ `man curl` / https://curl.se/docs/manpage.html

== âœ… Un client HTTP en ligne de commande

[source,bash]
----
curl http://google.com
# <HTML> ...

curl --verbose --output /dev/null http://google.com
#< HTTP/1.1 301 Moved Permanently
#< Location: http://www.google.com/
# ...

curl --location http://google.com
# <!doctype html> ...
----

== ğŸ“ AccÃ©der au serveur web via le rÃ©seau privÃ©

* *But :* Affichez la page du serveur web qui tourne dans le conteneur `webserver-1`

* Obtenez l'adresse IP privÃ©e du conteneur avec la commande https://docs.docker.com/engine/reference/commandline/container_inspect/[`docker container inspect`,window="_blank"]
* Utilisez la command `curl`

== âœ… AccÃ©der au serveur web via le rÃ©seau privÃ©

[source,bash]
----
docker container inspect webserver-1
# ...
# docker inspect webserver-1 | grep IPAddress

curl http://172.17.0.x:80 # x peut changer
# ...
<title>Welcome to nginx!</title>
# ...

docker container stop webserver-1

curl http://172.17.0.x:80
# Erreur
----

== RÃ©seau privÃ© / public

* Un rÃ©seau privÃ© doit le rester !
* Solution : publier le(s) port(s) sur les interface rÃ©seau publiques

== ğŸ“ AccÃ©der au serveur web via un port publiÃ©

* *But :* CrÃ©ez un nouveau conteneur `webserver-1` accessible publiquement

* Utilisez le port `8080` publique
* ğŸ’¡ Flag `--publish` pour `docker container run`
* ğŸ’¡ GitPod va vous proposer un popup : choisissez "Open Browser"

== âœ… AccÃ©der au serveur web via un port publiÃ©

[source,bash]
----
docker container run --detach --name=webserver-2 --publish 8080:80 nginx
1c5020a818887b1eb4b14b7e75f490db97fac4172c96cc918df63c8c2a0fbaff

curl http://localhost:8080
# ...
----

== Autres RÃ©seaux

image::docker-networks-all.png[width=800]

== ğŸ“ Autre RÃ©seaux

* Comparons les interfaces rÃ©seaux de la VM GitPod et de 3 conteneurs basÃ©s sur `alpine:3.17` :
** Un conteneur dans le rÃ©seau `default`
** Un conteneur avec `--network=host`
** Un conteneur avec `--network=none`

* ğŸ’¡ Commande `ip addr` pour afficher les interfaces rÃ©seaux sous Linux

== âœ… Autre RÃ©seaux

[source,bash]
----
$ ip addr
1: lo: # ...
  inet 127.0.0.1/8 scope host lo
# ...
4: docker0: # ...
# ...

$ docker container run --rm alpine:3.17 ip addr
1: lo:  # ...
  inet 127.0.0.1/8 scope host lo
# ...
  inet 172.17.0.x/16  # ...
# ...

$ docker container run --rm --network=host alpine:3.17 ip addr
1: lo: # ...
  inet 127.0.0.1/8 scope host lo
# ...
4: docker0: # ...
# ...

gitpod /workspace $ docker container run --rm --network=none alpine:3.17 ip addr
1: lo: # ...
  inet 127.0.0.1/8 scope host lo
----

== RÃ©seaux personnalisÃ©s

* Vous pouvez crÃ©er vos propres rÃ©seaux isolÃ©s les un des autres
* Le fonctionnement reste le mÃªme (IP privÃ©es, ports Ã  publier)
* Avantage: Pour chaque rÃ©seau "bridge" (hors `default`, Docker fournit un serveur DNS automatique !)

== ğŸ“ RÃ©seaux personnalisÃ©s 1/2

* CrÃ©ez un rÃ©seau nommÃ© `esgi-1` avec la commande `docker network create`

* ExÃ©cuter un conteneur avec les propriÃ©tÃ©s suivantes :
** Nom : `webserver-3`
** Type : dÃ©tachÃ© (tÃ¢che de fond)
** Dans le rÃ©seau `esgi-1` (ğŸ’¡ `--network=`)
** Image : `nginx`

== ğŸ“ RÃ©seaux personnalisÃ©s 2/2


* ExÃ©cutez un second conteneur interactif
** Interactif
** `--entrypoint=bash`
** RÃ©seau attachÃ© : `esgi-1`
** Image : `nginx`

* Essayez la commande `curl http://webserver-3`

== âœ… RÃ©seaux personnalisÃ©s

[source,bash]
----
docker network create ls
docker network create esgi-1
docker network create ls

docker container run --detach --network=esgi-1 --name=webserver-3 nginx

docker container run --rm --tty --interactive --network=esgi-1 --entrypoint=bash nginx
root@ac99e0beb95d:/# curl --verbose http://webserver-3
*   Trying 172.18.0.2:80...
* Connected to webserver-3 (172.18.0.2) port 80 (#0)
> GET / HTTP/1.1
> Host: webserver-3
> User-Agent: curl/7.74.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
# ...
----

== Checkpoint ğŸ¯

* Docker gÃ¨re les rÃ©seaux automatiquement pour vous
* Un conteneur peut exposer un service sur son rÃ©seau privÃ© et Ã©galement le publier
* Les rÃ©seaux personnalisÃ©s fournissent un serveur de nom de domaines intÃ©grÃ© ğŸ¦„
