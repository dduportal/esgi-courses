[{invert}]
= CI: Application d'exemple

== Application "Say Hello"

* Web application Ã©crite en NodeJS
* FonctionnalitÃ© : rÃ©ponds "Hello World" Ã  une requÃªte HTTP GET sur `/`

[source,js]
----
include::../code-samples/nodejs-app/index.js[]
----

== ğŸ“ Exercice : Essayons cette application dans GitPod

* CrÃ©ez un fichier `index.js` Ã  la racine de votre dÃ©pÃ´t avec le contenu de la slide prÃ©cÃ©dente
* Ouvrez 2 terminaux
** Dans le premier terminal, exÃ©cutez l'application :
+
[source,bash]
----
node ./index.js # CTRL-C to stop
----

** Dans le second terminal, faites-lui dire bonjour :
+
[source,bash]
----
curl --verbose http://127.0.0.1:3000
----

== ğŸ¤” Cycle de vie / Pipeline

* C'est tout ? Bien sÃ»r que non ! Il y a plein d'Ã©tapes (avant et aprÃ¨s)

* CommenÃ§ons par un cycle de vie NodeJS classique :
** RÃ©cupÃ©ration des dÃ©pendances
** Lint (Analyse statique)
** Test (peu importe le type)

* ğŸ’¡ https://www.npmjs.com/[NPM] Ã  la rescousse

== ğŸ“ Exercice : Mise en place d'un cycle de vie 1/2

* CrÃ©ez un fichier `package.json` Ã  la racine de votre dÃ©pÃ´t:

[source,json]
----
include::../code-samples/nodejs-app/package.json[lines="1..7,9..22"]
----

== ğŸ“ Exercice : Mise en place d'un cycle de vie 2/2

* Essayez de lancer l'application dans GitPod :

[source,bash]
----
# RÃ©cupÃ©rer les dÃ©pendances - PrÃ©requis systÃ©matique
npm install

# ExÃ©cuter le script "launch-app"
npm run start # CTRL-C to stop

# Second terminal:
curl --verbose http://127.0.0.1:3000
----

== ğŸ“ Exercice : Lint de l'application dans GitPod

[source,bash]
----
npm run lint
# Indique une erreur
# index.js: line 7, col 27, Missing semicolon.
----

== ğŸ¯ Checkpoint

On a donc un pipeline Ã  2 Ã©tapes :

** RÃ©cupÃ©ration des dÃ©pendances
** Lint (qui indique une erreur).

// TODO: workflow image

== ğŸ“ Exercice : Mise en place du CI Node/NPM

* *But :* exÃ©cuter les mÃªmes Ã©tapes que prÃ©cÃ©demment dans GitHub Actions
* Modifiez votre workflow pour :
** Ajouter `node_modules/` dans un fichier `.gitignore` Ã  la racine
** Enlever les commandes "cowsay" de l'exercice prÃ©cÃ©dent
** ExÃ©cuter les commandes `npm install` puis `npm run lint` dans 2 Ã©tapes distinctes

âŒ RÃ©sultat attendu : la mÃªme erreur

== âœ… Solution : Mise en place du CI Node/NPM

[source,yaml]
----
include::../code-samples/gh-actions/ci-nodejs.yml[tags="common,initial"]
----


== ğŸ“ Exercice : Corriger le CI

* *But:* Le workflow est toujours en Ã©chec. Faites le nÃ©cessaire pour corriger les erreurs

== ğŸ¤” Environnement d'exÃ©cution du CI

*ProblÃ¨me* : On souhaite avoir les mÃªmes outils dans notre CI ainsi que dans nos environnement de dÃ©veloppement

* Environnement d'exÃ©cutions diffÃ©rents :
** SystÃ¨me d'exploitation ? (macOS, Windows, Ubuntu Linux, Arch Linux, etc.)
** Architecture du processeur ? (Intel, AMD, ARM, PowerPC, Risc-V, etc.)
** SDKs installÃ©s (quelle version de NodeJS ? et de NPM ? etc.)

ğŸš§ Que dis l'Ã©tape "npm install du workflow ?

// `Unsupported engine `

== ğŸ“ Exercice : CI avec le tooling NodeJS

* *But* : Utilisez l'action GitHub https://github.com/actions/setup-node[] pour avoir la mÃªme version de NodeJS + NPM que dans GitPod

* ğŸ‘·ğŸ½â€â™€ï¸ C'est Ã  vous de mettre Ã  jour le workflow pour que l'Ã©tape `npm install` ne signale plus d'incompatibilitÃ© de version

== âœ… Solution : CI avec le tooling NodeJS

[source,yaml]
----
include::../code-samples/gh-actions/ci-nodejs.yml[tags="common,initial"]
----


// == !

// * Quel est l'impact en terme de temps d'exÃ©cution du changement prÃ©cÃ©dent ?

// * *ProblÃ¨me :* Le temps entre une modification et le retour est crucial

// image::wait-here.jpg[]

// == ğŸ¤” ProblÃ¨me : AccÃ©lÃ©rer le workflow

// * *ProblÃ¨me :*
// ** Optimiser prÃ©maturÃ©ment est contre-productif (commencez par faire un systÃ¨me qui marche comme prÃ©vu)
// ** Mais il faut bien s'y coller Ã  un moment donnÃ©

// == ğŸ“ Exercice : Environnement prÃ©fabriquÃ© local

// * *But :* Utiliser un `Dockerfile` pour fabriquer une image Ã  utiliser

// * ğŸ¤” https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idcontainer[GitHub Actions ne permet pas de spÃ©cifier un `Dockerfile`]

// * C'est Ã  vous. Mettez Ã  jour votre workflow pour :
// ** Fabriquer une image Docker contenant `cowsay` et basÃ©e sur le mÃªme Ubuntu que Gitpod
// ** https://docs.docker.com/engine/reference/builder/#copy[Copier le fichier `README`] dans l'image
// ** ExÃ©cuter la commande `cowsay` avec l'aide d'un conteneur avec
// +
// [source,bash]
// ----
// bash -c " cat /README.md | /usr/games/cowsay"
// ----

// == âœ… Exercice : Environnement prÃ©fabriquÃ© local

// [source,Dockerfile]
// ----
// # Dockerfile
// FROM ubuntu:20.04
// RUN apt-get update && apt-get install --yes cowsay
// COPY ./README.md /README.md
// ----

// [source,yaml]
// ----
// # bonjour.yml
// include::../code-samples/gh-actions/ci-docker-build.yml[]
// ----

// == ğŸ¤” RÃ©flÃ©chissons ensemble

// - Impact sur le temps de build ?
// - Quelles limites voyez-vous ?

// == Checkpoint ğŸ¯

// - On peut exÃ©cuter des tÃ¢ches de CI dans des images de container
// - Un curseur est Ã  positionner entre des images prÃ©fabriquÃ©es qui peuvent Ãªtre lourdes ou fabriquer soit-mÃªme sa propre image
